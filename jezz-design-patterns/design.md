### 责任链模式

链式处理,例如审批

    Handle : 定义责任的接口,通常在这里处理请求,实现后继链
    XXXHandle : 定义责任的类,处理他责任范围内的请求,如果不处理,转交给后续链
    Client : 向链上的具体处理者对象提交请求，让责任链负责处理

### 策略模式

优化if else 代码

    IStrategy : 策略接口角色
    XXXStrategy : 具体的策略
    StrategyContext : 策略上下文,负责和具体的策略实现交互,通过构造器注入接口角色,调用接口的方法
    Client : 外部客户端,调用策略上下文
    
### 适配器模式 

将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作

    目标（Target）接口 : 它可以是抽象类或接口
    适配者（Adaptee）类 : 它是被访问和适配的现存组件库中的组件接口(类)
    适配器类(XXXAdapter)类 : 它是一个转换器，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。
 
#### 1.类适配器模式

    适配器（XXXClassAdapter）类 : 通过继承适配者实现目标接口
    
#### 2.对象适配器模式
    
    适配器（XXXObjectAdapter）类 : 实现目标接口,构造器注入适配者,调用适配者方法
    
### 装饰模式

指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）

    Component : 原组件
    ConcreteComponent : 原组件实现类
    Decorator : 抽象装饰者,实现了原组件,构造器注入原组件
    ConcreteDecorator : 继承抽象装饰者,添加附加的功能
    
### 建造者模式(telescoping)

背景 : 传统实例需要在多个参数的构造器下选取构造器(例:OldUser1), 或者用javabeans(例:OldUser2),使用无参构造器,然后new 对象,
但是JavaBeans的模式无法创建不可变的类，因此需要编程者花费其他成本来保证线程安全
使用 : idea下载innerBuilder插件自动生成

    User : 实例对像 (不可变的可以定义为final 保证线程安全), 创建一个构造方法参数是Build
    Builder : 静态内部类 不可变的必须要有的要创建构造方法, 定义每个参数的 生成方法 返回this, 创建build方法调用实例对象的构造方法 new一个 实例对象;

### 工厂模式

#### 简单工厂模式

    就是建立一个工厂类IFactory，对实现了同一接口的一些类进行实例的创建

#### 工厂方法模式

工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建

##### 静态工厂方法模式

大多数情况下，我们会选用静态工厂方法模式,静态工厂注入Mapper 或者 service 实例时,需注意使用@postconstruct注解注释的方法将成员变量转换成静态变量 

    将每个实例获取的方法置为静态的，不需要创建实例，直接调用即可


##### 抽象工厂模式

后续新增产品就只需要新增一个产品接口实现类和 抽象工厂实现类

    AbstractFactory : 抽象工厂接口,里面有方法getInstance,用来获取工厂实例
    XXXFactory : 实现抽象工厂
    IFactory : 产品接口,需要实现
    XXXSender : 实现产品接口处理逻辑

## 参考文献/博客

   [设计模式博客](http://c.biancheng.net/view/1361.html)