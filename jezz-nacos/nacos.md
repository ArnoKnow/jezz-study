# 1.cap 理论

CAP理论为:一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。
一致性是指数据在多个副本之间是否能够保持一致的特性,在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。
可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。
分区容错性约束了一个分布式系统需要具有如下特性:分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络都发生了故障。

# 2.base 理论

BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。
基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性
例子: 响应时间上的损失(查询1s需要5秒了)，功能上的损失(引导到降级页面)
软状态是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。
最终一致性强调的是系统中所有的数据副本，经过一段时间的同步后，最终能够达到一个一致的状态，而不需要实时保证系统数据的强一致性。

# 为了解决分布式一致性的问题 产生的算法

## 2pc (两阶段提交) ----> 强一致性的算法
阶段一: 提交事务请求
1.事务询问 --> 2.执行事务 --> 3.各参与者向协调者反馈事务询问的响应
白话文: 1.协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应
       2.各参与者执行事务操作，并将Undo和Redo信息记入事务日志中
       3.如果参与者成功执行了事务操作，那么就反馈给协调者Yes响应，表示事务可以执行;如果参与者没有成功执行事务，那么就反馈给协调者No响应，表示事务不可以执行。
阶段二: 执行事务提交
前提:假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务提交
1.发送提交请求 --> 2.事务提交 --> 3.反馈事务提交结果 --> 4.完成事务
白话文: 1.协调者向所有参与者节点发出Commit请求
       2.参与者收到Commit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源
       3.参与者在完成事务提交之后，向协调者发送ack消息
       4.协调者接手到所有参与者反馈的Ack消息后，完成事务。
中断事务
前提:假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法收到所有参与者的反馈响应，那么就会中断事务。
1.发送回滚请求 --> 2.事务回滚 --> 3.反馈事务回滚结果 --> 4.中断事务
白话文: 1.协调者向所有参与者节点发出Rollback请求
       2.参与者接手到Rollback请求后，会利用其在阶段一种记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源
       3.参与者在完成事务回滚之后，向协调者发送Ack消息
       4.协调者接收到所有参与者反馈的Ack消息后，完成事务中断
       
优点: 原理简单，实现方便
缺点: 同步阻塞，单点问题，脑裂，太过保守
同步阻塞:在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说各个参与者在等待其他参与者响应的过程中，将无法进行其他任何操作
单点:协调者出现问题，整个二阶段提交流程将无法运转，如果协调者是在二阶段中出现问题的话，那么其他参与者将一直处于锁定事务资源的状态中，无法继续完成事务操作。
数据不一致:当协调者向所有参与者发送Commit请求后，发生了局部网络异常，或者协调者在尚未发送完Commit请求之前自身发生了崩溃，导致最终只有部分参与者收到Commit请求，于是
这部分收到了Commit请求的参与者就会进行事务的提交，而其他没有收到Commit请求的参与者则无法进行事务提交，于是就发生了数据不一致现象。
太过保守:协调者指示参与者进行事务提交询问的过程中，参与者出现故障而导致协调者始终无法获得所有参与者的响应信息的话，协调者只能依靠自身超时机制来处理，这样的策略过于保守
二阶段协议没有较为完善的容错机制，任何一个节点的失败都会导致整个事务的失败
       
## 3pc (三阶段协议)
将二阶段协议中的阶段一  提交事务请求 一分为二 形成了 CanCommit PreCommit DoCommit 三个阶段组成的事务处理协议
阶段一: canCommit
1.事务询问 --> 2.各参与者向协调者反馈事务询问的响应
白话文: 1.协调者向所有参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应
       2.参与者在接收到来自协调者得canCommit请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈Yes响应，并进入预备状态,否则反馈No响应。
阶段二: preCommit 
执行事务预提交
1.发送预提交请求 --> 2.事务预提交 --> 3.各参与者向协调者反馈事务执行的响应
白话文: 1.协调者向所有参与者节点发出preCommit的请求，并进入Prepared阶段
       2.参与者接收到preCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中
       3.如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令:提交或终止。
中断事务
假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。
1.发送中断事务请求 --> 2.中断事务
阶段三: doCommit
执行提交
1.发送提交请求 --> 2.事务提交 --> 3.反馈事务提交结果 --> 4.完成事务
白话文: 1.假设协调者处于正常工作状态，并且它接收到了来自所有参与者的Ack响应，那么它将从预提交状态转换到提交状态并向所有的参与者发送doCommit请求
       2.参与者接收到doCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源
       3.参与者在完成事务提交之后，向协调者发送Ack消息
       4.协调者接收到所有参与者反馈的Ack消息后，完成事务
中断事务
假如协调者处于正常工作状态，并且有任意一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务
1.发送中断请求 --> 2.事务回滚 --> 3.反馈事务回滚结果 --> 4.中断事务
进入阶段三可能会存在2种故障 协调者出现问题,协调者和参与者之间的网络出现故障，参与者都会在等待超时之后，继续进行事务提交
优点: 降低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致
缺点: 三阶段提交协议去除阻塞的同时，如果在参与者接收到preCommit消息后，如果网络出现分区，协调者所在的节点和参与者无法进行正常的网络通信，该参与者依然会进行事务的提交，
必然会出现数据不一致。

## Paxos 算法 (基于消息传递且具有高度容错特性的一致性算法)

背景:拜占庭式问题

需求: 只有被提出的提案才能被选定
     只能有一个值被选定
     如果某个进程认为某个提案被选定了，那么这个提案必须是真的被选定的那个
     
角色: Proposer,Acceptor,Learner

提案的选定:
推导: 在没有拜占庭式问题的情况下，假设只有一个Proposer发出了一个提案 ，仍然要选出一个提案
     P1: 每一个Acceptor必须批准他收到的第一个提案
问题:如果有多个Proposer发出了多个提案,那么每个Acceptor接收到他的第一个提案，比如p1提出了提案v1被a1批准,p2提出了提案v2被a2批准会导致,
    p3提出了提案v3被a3批准, 这样就会导致没有一个提案是多数人批准的
    eg: p1->a1=v1 p2->a2=v2 p3(协调者)->a3(参与者)=v3(提案)
    其次是p1提出了提案v1被a1，a2批准了，p2提出了提案v2被a3，a4，a5批准了，但是a5挂了，这样就会导致每个提案被差不多Acceptor批准了还是无法选定提案
推导出:在p1的基础上，再加上一个提案被选定需要由半数以上的Acceptor批准的需求暗示着一个Acceptor必须能够批准不止一个提案
    可以用全局编号[M<sub>n,V<sub>n]标识提案进行区分,虽然允许多个提案被选定,但是要求保证被选定的提案都有相同的value值
约定:
    P2:编号为M<sub>0、Value值为V<sub>0的提案(即[M<sub>0,V<sub>0])被选定了,那么所有比编号M<sub>0更高的,且被选定的提案，其value值也必须是V<sub>0;
一个提案被选定首先至少要有一个Acceptor批准所以推导出:
    P2a:编号为M<sub>0、Value值为V<sub>0的提案(即[M<sub>0,V<sub>0])被选定了,那么所有比编号M<sub>0更高的,且被Acceptor批准的提案，其value值也必须是V<sub>0;
假如p1提出了提案[M<sub>1,V<sub>2]还没有被批准过,p2提出了提案[M<sub>0,V<sub>1]被a2,a3,a4,a5批准了，超过半数被批准则被选定,此时产生了一个编号更高的提案[M<sub>1,V<sub>2]
与P2a矛盾，因为值不相同。
推导:需要对p2a加强
    P2b:如果一个提案[M<sub>0,V<sub>0]被选定后,之后Proposer产生的编号更高的提案,其value值都为V<sub>0;
推导:
    P2c:对于任意M<sub>n和V<sub>n,如果提案[M<sub>n,V<sub>n]被提出,那么肯定存在一个由半数以上Acceptor组成的集合S，满足下列条件的任何一个:
    1.S中不存在任何批准过编号小于M<sub>n的提案的Acceptor
    2.选取S中所有Acceptor批准的编号小于M<sub>n的提案，其中编号最大的那个提案其Value值是V<sub>n;

Proposer生成提案  (在P2c的前提下)  

预请求(prepare)
<1>.Proposer选取一个新的提案编号M<sub>n,然后向某个Acceptor集合成员发送请求,要求该集合中的Acceptor进行如下响应:
  1.向Proposer承诺,保证不再批准任何编号小于M<sub>n的提案
  2.如果Acceptor已经批准过任何提案,那么就向Proposer反馈当前该Acceptor已经批准的编号小于M<sub>n但是是最大编号的那个提案的值。
<2>.如果Proposer收到了半数以上的Acceptor的响应结果,那么就会产生编号为M<sub>n,值为V<sub>n的提案,V<sub>n就是响应中编号最大的提案的值
    如果半数以上Acceptor没有批准过任何提案，那么V<sub>n的值由Proposer任意选定
    
Acceptor批准提案
一个Acceptor可能会接收到2种请求,分别是Prepare请求和Accept请求
Prepare请求:Acceptor可以在任何时候响应一个Prepare请求
Accept请求:在不违背Accept现有承诺的前提下，可以任意响应Accept请求

约束: P1a:一个Acceptor只要未响应过任何编号大于M<sub>n的Prepare请求，那么他就可以接受这个编号为M<sub>n的提案。